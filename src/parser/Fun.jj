/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;
import java.io.*;
import recovery.*;
import syntaticTree.*;

public class Fun
{
  final static String Version = "Top Compiler - Version 1.0 - 2018";
  int contadorDeErrosSintaticos = 0;
  boolean debug_recovery;
  Token ultimoErro = null;

  final static String CaminhoDoArquivo = "\\Users\\ronaldostranger\\Downloads\\entradatestevalido.txt";

  public static void main(String args []) throws ParseException
  {
    boolean debug = false;
    boolean debug_as = false;
    boolean debug_recovery = true;
    String nomeArquivo = CaminhoDoArquivo;
    Fun analisador = leArquivo(nomeArquivo);
    System.out.println(Version);
    int i;
    for (i = 0; i < args.length - 1; i++)
    {
      switch (args [i])
      {
        case "-debug_AS" : 
        debug = true;
        break;
        case "-debug_recovery" : 
        debug_recovery = true;
        break;
        default :
        {
          System.out.println("Usage is" + "java Fun [-debug_AS] inputfile");
          System.exit(0);
        }
      }
    }
    analisador.debug_recovery = debug_recovery;
    desabilitaVerboseDoAS(analisador, debug);
    try
    {
      analisador.program();
    }
    catch (ParseEOFException e)
    {
      System.err.println(e.getMessage());
    }
    finally
    {
      System.out.println(analisador.token_source.foundLexError() + ": Erros Lexicos encontrados");
      System.out.println(analisador.contadorDeErrosSintaticos + ": Erros Sintaticos encontratos");
    }
    if (temErros(analisador) == false)
    {
      System.out.println("Programa analisado com sucesso!");
    }
  } //main

  public static void desabilitaVerboseDoAS(Fun analisador, boolean debug)
  {
    if (!debug)
    {
      analisador.disable_tracing();
    }
  }

  public static boolean temErros(Fun analisador)
  {
    if (analisador.token_source.foundLexError() != 0)
    {
      System.out.println(analisador.token_source.foundLexError() + " erros l\u00e9xicos encontrados");
    }
    return false;
  }

  public static Fun leArquivo(String nomeArquivo)
  {
    try
    {
      System.out.println("Lendo do arquivo " + nomeArquivo + "\n");
      return new Fun(new java.io.FileInputStream(nomeArquivo));
    }
    catch (java.io.FileNotFoundException e)
    {
      System.out.println("Arquivo " + nomeArquivo + " n\u00e3o encontrado.");
      return null;
    }
  }

  static public String im(int x)
  {
    int ultimoIndice;
    String identificadorToken;
    identificadorToken = tokenImage [x];
    ultimoIndice = identificadorToken.lastIndexOf("\"");
    try
    {
      identificadorToken = identificadorToken.substring(1, ultimoIndice);
    }
    catch (StringIndexOutOfBoundsException e)
    {
    }
    return identificadorToken;
  }
  boolean isEndOfFile;

  void consomeTokenAteh(RecoverySet conjuntoTokens, ParseException e, String met) throws ParseEOFException, ParseException
  {
    Token token;
    if (debug_recovery)
    {
      System.out.println();
      System.out.println("*** " + met + " ***");
      System.out.println("\u0009Sincronizando Set: " + conjuntoTokens);
    }
    if (conjuntoTokens == null)
    {
      throw e;
    }
    token = getToken(1);
    while (!isEndOfFile)
    {
      if (conjuntoTokens.contains(token.kind))
      {
        if (debug_recovery)
        {
          System.out.println(" Encontrou token de sincroniza��o -> " + im(token.kind));
          break;
        }
      }
      if (debug_recovery)
      {
        System.out.println("\u0009Ignorando token: " + im(token.kind));
      }
      getNextToken();
      token = getToken(1);
      if (token.kind == EOF && !conjuntoTokens.contains(EOF))
      {
        isEndOfFile = true;
      }
    }
    if(token != ultimoErro)
    {
    	System.out.println(e.getMessage());
    	ultimoErro = token;
    	contadorDeErrosSintaticos++;
    }
    
    
    if (isEndOfFile)
    {
      throw new ParseEOFException("Final de arquivo encontrado prematuramente");
    }
  }
}

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
  int countLexError = 0;

  public int foundLexError()
  {
    return countLexError;
  }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

TOKEN : //operadores
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NEQ : "!=" >
| < REM : "%" >
| < NOT : "not" >
| < AND : "and" >
| < OR : "or" >
| < XOR : "xor" >
}

TOKEN : //palavras reservadas
{
  < BREAK : "break" >
| < CLASS : "class" >
| < CONSTRUCTOR : "constructor" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FOR : "for" >
| < WHILE : "while" >
| < IF : "if" >
| < INT : "int" >
| < NEW : "new" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < STRING : "string" >
| < SUPER : "super" >
  //nosso
| < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
}

TOKEN : //simbolos especiais
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

TOKEN :
{
  < tipo_INT :
    ( // numeros decimais, octais, hexadecimais ou binarios
      (
        [ "0"-"9" ] ([ "0"-"9" ])* //um ou mais digidos
      )
    ) >
| 
  < tipo_FLOAT :
    ( // floats
      (
        ([ "0"-"9" ])+ [ "." ] ([ "0"-"9" ])+ //pelo menos um digito de 0 a 9, seguido por um unico ponto e pelo menos mais um digito de 0 a 9
      )
    ) >
| 
  < tipo_STRING : // constante string como "ab cd"
    "\"" (~[ "\"", "\n", "\r" ])* "\"" > //aspas seguidas por qualquer coisa que nao seja aspas ou quebra de linha, terminando com aspas. Pode nao ter nada entre as aspas
| < tipo_NULL : "null" > //constante null
| < tipo_CHAR : // constante CHAR como 'a'
    "\'" (~[ "\\" ]) "\'"
  | "\'"
    (
      "\\n"
    | "\\r"
    | "\\t"
    | "\\\""
    | "\\\'"
    | "\\\\"
    )
    "\'" > //aspas simples seguidas por qualquer digito unico que nao seja aspas simples ou quebra de linha, terminando com as pas simples.
| < tipo_BOOLEAN :
    (
      "true"
    | "TRUE"
    | "false"
    | "FALSE"
    ) 
  >
}

TOKEN : //identificadores
{
  < tipo_Identificador : //qualquer combinacao de letras e numeros que comece com uma letra
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >
| 
  < #DIGIT : [ "0"-"9" ] >
}

SKIP : //comentarios
{
  "/*" : multilinecomment
}

< multilinecomment >
SKIP :
{
  "*/" : DEFAULT
| < ~[ ] >
}

SKIP :
{
  "//" : singlelinecomment
}

< singlelinecomment >
SKIP :
{
  < [ "\n", "\r" ] > : DEFAULT
| < ~[ ] >
}

SPECIAL_TOKEN : //trata erros lexicos
{
  < INVALID_LEXICAL : 
    (~[ "a"-"z", 
    "A"-"Z", 
    "0"-"9", 
    "\"", 
    "(", 
    ")", 
    "[", 
    "[", 
    "{", 
    "{", 
    ";", 
    ",", 
    ".", 
    "'", 
    "=", 
    ">", 
    "<", 
    "!", 
    "+", 
    "-", 
    "*", 
    "/", 
    "%", 
    " ", 
    "\t", 
    "\n", 
    "\r", 
    "\f" 
    ])+ >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Elemento invalido encontrado: " + image);
    countLexError++;
  }
| 
  < INVALID_STRING : 
    "\"" (~[ "\n", "\r", "\"" ])* [ "\n", "\r" ] >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - A string possui uma quebra de linha inesperada: " + image);
    countLexError++;
  }
| 
  < INVALID_CHAR :
    "\'" (~[ "\n", "\r", "\'" ])* [ "\n", "\r" ] //char com quebra de linha
  | 
    "\'" (~[ "\n", "\r", "\'" ]) (~[ "\n", "\r", "\'" ])+ "\'" //char com mais de um caractere
  | 
    "\'" "\'" //char vazio
  | 
    "\'" "\\" "\'" //char do tipo '\'
  >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Char invalido: " + image);
    countLexError++;
  }
}

// Inicializacao do parser
ListNode program() throws ParseEOFException :
{
  RecoverySet g = First.program;
  ListNode l= null, d= null;
}
{
  <EOF>
|
	l= classlist(g)
  try
  {
     //[ classlist(g) ] < EOF >// Livro est� diferente.
    <EOF> { return 1; }
  }
  catch (ParseException e)
  {
    consomeTokenAteh(g, e, "program");
  }
  [ d= program() ]
  { return 1; }
    
}
/* Chama o classdecl passando como conjunto de sync o conjunto g, e todos terminais que est�o
no FIRST(classlist). Isso porque depois do classdecl podemos ter um classlist ou
o final da aplica��o dessa produ��o */
ListNode classlist(RecoverySet g) throws ParseEOFException :
{
  ClassDeclNode c = null;
  ListNode l = null;
  RecoverySet f = First.classlist.union(g);
}
{
  c = classdecl(f) [ l = classlist(g) ]
  {  return new ListNode( c, l); } 
}

// declaracao de classe Ex : class nome extends nomePai
// alterado de acordo com o livro (Programa 5.8)
ClassDeclNode classdecl(RecoverySet g) throws ParseEOFException :
{
  Token t1 = null, t2 = null, t3 = null;
  ClassBobyNode c1 = null;
}
{
  try {
    	t1 = < CLASS > t2 = < tipo_Identificador > [ < EXTENDS > t3 = < tipo_Identificador > ] c1 = classbody(g)
    	{ return new ClassDeclNode(t1, t2, t3, c1); }
	} catch (ParseException e){
	  consomeTokenAteh(g, e, "classcl");
	  return new ClassDeclNode(t1, t2, t3, c1);
	}
}
//declaracao de corpo da classe, podendo criar variaveism, construtores, metodos dentro das chaves 
ClassBodyNode classbody(RecoverySet g) throws ParseEOFException :
{
  ListNode c = null,
  		   v = null,
  		   ct = null,
  		   m = null,
  VarDeclNode vd;
  ConstructDeclNode cd;
  MethodDeclNode md;
  Token t = null;

  RecoverySet 	f2 = new RecoverySet(SEMICOLON).union(g).remove(tipo_Identificador),
				f3 = First.methoddecl.union(g).remove(tipo_Identificador), //ao inv�s de union g, estava union f1
				f4 = First.constructdecl.union(f3).remove(tipo_Identificador),
				f5 = First.vardecl.union(f4).remove(tipo_Identificador);
}
{ //Essa parte t� diferente do livro, deixei como tava no livro. p�gina 100 (p�gina impressa).
  try {  
  t = < LBRACE > 
  [ c = classlist(f5) ]
  (LOOKAHEAD(3) vd = vardecl(f2) < SEMICOLON >
	{	if (v == null)
			v = new ListNode(vd);
		else
			v.add(vd);
	}
  )*  
  (
    (cd = constructdecl(f4)
    { if (ct == null)
    	ct = new ListNode(cd);
      else
      	m.add(md) })
   |
  (methoddecl(f3)
  	{ if (m == null)
  		m = new ListNode(md);
  	  else
  	  	m.add(md); }
  ))*
  < RBRACE >
  { return new ClassBodyNode(t, c, v, ct, m); }
} catch (ParseException e){
		consomeTokenAteh(g, e, "classbody");
		return new ClassBodyNode(t, c, v, ct, m);
	}
}

// declaracao de uma variavel com opcional de array e tambem a possibilidade de inicialzacao
void vardecl(RecoverySet g) throws ParseEOFException :
{
  Token t1 = null, t2;
  int k = 0;
  ListNode l = null;
}
{
  try { 
	 (
    t1 = < INT >
  | t1 = < STRING >
  | t2 = < tipo_Identificador >(< LBRACKET >(< tipo_Identificador >|< tipo_INT >)* < RBRACKET > { k++ })*
  { l = new ListNode(new VarNode(t2, k)); }
  | t1 = < CHAR >
  | t1 = < FLOAT >
  | t1 = < BOOLEAN >
  )
  (
   //t2 = < tipo_Identificador > (< LBRACKET >< RBRACKET > {  k++ })*)* // TODO test verificar comma
   < COMMA > { k = 0; } t2 = < tipo_Identificador > (< LBRACKET > < RBRACKET > { k++; }
   { l.add(new VarNode(t2, k)); })*
   
  (
    assigndecl(g)
  )?
  { return new VarDeclNode(t1, l) }
  } catch(ParseException e) {
    consomeTokenAteh(g, e, "vardecl");
    return new VarDeclNode(t1, l);
  }
}

// declacarao de atribuicao de variavel
void assigndecl(RecoverySet g) throws ParseEOFException :
{
}
{
  try 
  {
	< ASSIGN >
	(
	  assignbody(g)
	)
  } catch(ParseException e) {
	consomeTokenAteh(g, e, "vardecl");
  }
}

// atribuicao podendo ser todos os tipos ou array
void assignbody(RecoverySet g) throws ParseEOFException :
{
}
{
  
  (LOOKAHEAD(3)(
    (
	    alocexpression(g) | expression(g) 
	  )?
	| 
	    (
	   		tipobody() (< LBRACKET > < RBRACKET >)?
	  	)
	)
	| < tipo_NULL >)
}

void tipobody() :
{
}
{
	 (
	      < tipo_CHAR >
	    | < tipo_STRING >
	    | < tipo_INT >
	    | < tipo_FLOAT >
	    | < tipo_BOOLEAN >
	    | < tipo_Identificador >
    )
}

// declaracao de construtor
ConstructDeclNode constructdecl(RecoverySet g) throws ParseEOFException :
{
    Token t = null;
    MethodBodyNode m = null;
}
try {
    t = < CONSTRUCTOR > m = methodbody(g)
    { return new ConstructDeclNode(t, m); }
}
catch(ParseException e)
{
    consomeTokenAteh(g, e, "constructdecl");
    { return new ConstructDeclNode(t, m); }
}

// declaracao de metodo
MethodDeclNode methoddecl(RecoverySet g) throws ParseEOFException :
{
    Token t1 = null, t2 = null;
    int k = 0;
    MethodBodyNode m = null;
}
{
  try {
    (
        t1 = < INT >
    | t1 = < STRING >
    | t1 = < tipo_Identificador >
    | t1 = < CHAR >
    | t1 = < FLOAT >
    | t1 = < BOOLEAN >
    )
    (< LBRACKET >< RBRACKET > { k++ ;} )* 
    t2 = < tipo_Identificador > m = methodbody(g)
        { return new MethodDeclNode(t2, k , t2, m); }
  }
  catch(ParseException e) {
      consomeTokenAteh(g, e, "methoddecl");
      return new MethodDeclNode(t2, k , t2, m);
  }
}

// corpo do m�todo usado tanto no construtor quando no executando com (parametros*)
MethodBodyNode methodbody(RecoverySet g) throws ParseEOFException :
{
  Token t1 = null;
  ListNode l = null;
  StatementNode s = null;
  RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
  try {
      t1 = < LPAREN > l = paramlist(f) < RPAREN > s = statement(g)
      { return new MethodBodyNode(t1, l, s); }
  } catch (ParseException e){
    consomeTokenAteh(g, e, "methodbody");
    return new MethodBodyNode(t1, l, s);
  }
}

// lista de paramatros que podem ou nao ser inicializados TODO Verificar alterar pag 142 # 154
ListNode paramlist(RecoverySet g) throws ParseEOFException :
{
  ListNode = = null, q = null;
  int k = 0;
  Token t1 = null, t2 = null;
}
{//Isso aqui ta bem diferente do que est� no livro no fim da p�gina impressa 101
try {
  [
    vardecl(g) //adicionei o g como parametro porque � o que estava fazendo nos outros
    (
      < COMMA >
      (
        vardecl(g) //adicionei o g como parametro porque � o que estava fazendo nos outros
      )*
    )*
  ]
} catch (ParseException e) {
	consomeTokenAteh(g, e, "paramlist");
	return null;
}
}

// declaracao de corpo, usado em if, for, metodo:
StatementNode statement(RecoverySet g) throws ParseEOFException :
{
  StatementNode s = null;
  ListNode l;
  Token t1 = null;
  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g).remove(tipo_Identificador);
  RecoverySet f2 = new RecoverySet(RBRACE).union(g).remove(tipo_Identificador);
}
{
  try {
  
  LOOKAHEAD(2) //livro diferente, antes estava: LOOKAHEAD(2) <tipo_Identificador> <tipo_Identificador>
  s = vardecl(f1)
| 
  LOOKAHEAD(3) // livro diferente, antes estava: LOOKAHEAD(3) LOOKAHEAD(1)
  s = atribstat(f1) < SEMICOLON >
| 
  s = expression(f1) < SEMICOLON >
| 
  s = printstat(f1) < SEMICOLON >
| 
  s = readstat(f1) < SEMICOLON >
| 
  s = returnstat(f1) < SEMICOLON >
| 
  s = superstat(f1) < SEMICOLON >
| 
  s = ifstat(g)
| 
  s = forstat(g)
| 
  t1 = < LBRACE > l = statlist(f2) < RBRACE > {  s = new BlockNode(t1, l); }
| 
  t1 = < BREAK > < SEMICOLON > {  s = new BreakNode(t1); }
| 
  t1 = < SEMICOLON > {  s = new NopNode(t1); }
  { return s; }
} catch (ParseException e) {
	consomeTokenAteh(g, e, "statement");
	return new NopNode(t1);
}
}

// declaracao de atribuicao com operadores e expressoes
AtribNode atribstat(RecoverySet g) throws ParseEOFException :
{
  ExpreNode e1 = null, e2 = null;
  Token t1 = null;
  RecoverySet f1 = new RecoverySet(ASSIGN).union(g);
}
{
  try {
	e1 = lvalue(f1) t1 = < ASSIGN >
  (
    e2 = alocexpression(g)
  | LOOKAHEAD(2) //no livro n�o tem esse lookahead
    e2 = expression(g)
  | e2 = content(g)  //n�o sei se � g ou f1, no livro n�o tem esse content... colocando g, aqui pode dar pau
  )
  { return new AtribNode(t1, e1, e2); }
  } catch (ParseException e) {
	consomeTokenAteh(g, e, "atribstat");
	return new AtribNode(t1, e1, e2);
  }
  
}

// funcao de conteudo criada para poder fazer atribuicao nas variaves TODO rever
ExprNode content(RecoverySet g) throws ParseEOFException :
{
  Token t1 = null;
}
{
  (
   t1 = < tipo_CHAR >
  |t1 = < tipo_FLOAT >
  |t1 = < tipo_BOOLEAN >
  )
  < SEMICOLON >
}

// palavra reservada print
void printstat(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
	  < PRINT > expression(g)
	} catch (ParseException e) {
		consomeTokenAteh(g, e, "printstat");
	}
}

// palavra reservada read
void readstat(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
 	 < READ > lvalue(g)
	} catch (ParseException e) {
		consomeTokenAteh(g, e, "readstat");
	}
}

void returnstat(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
  	< RETURN > [ expression(g) ]
  } catch (ParseException e) {
		consomeTokenAteh(g, e, "returnstat");
	}
}

void superstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
  try { 
  < SUPER > < LPAREN > arglist(f) < RPAREN >
  } catch (ParseException e) {
		consomeTokenAteh(g, e, "superstat");
	}
}

void ifstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(RPAREN).union(g),
  			  f2 = new RecoverySet(ELSE).union(g);
}
{
  try { 
  < IF > < LPAREN > expression(f1) < RPAREN > statement(f2)
  [
    LOOKAHEAD(3)
    < ELSE > statement(g)
  ]
  } catch (ParseException e) {
		consomeTokenAteh(g, e, "ifstat");
	}
}

void forstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g),
  			  f2 = new RecoverySet(RPAREN).union(g);
}
{
  try { 
  < FOR > < LPAREN > [ atribstat(f1) ] < SEMICOLON > 
  [ expression(f1) ] < SEMICOLON > 
  [ atribstat(f2) ] < RPAREN > 
  statement(g)
  } catch (ParseException e) {
		consomeTokenAteh(g, e, "forstat");
	}
}

// lista de declaracoes
ListNode statlist(RecoverySet g) throws ParseEOFException :
{
  ListNode l - null;
  StatementNode s = null;
  RecoverySet f = First.statlist.remove(tipo_Identificador).union(g);
}
{
  s = statement(f) [ l = statlist(g) ]
}

// funcao de atribuicao a esquerda
ExpreNode lvalue(RecoverySet g) throws ParseEOFException :
{
  ExpreNode e1 = null;
  			e2 = null;
  Token t1 = null;
  		t2 = null;
  ListNode l = null;
}
{
  try { 
  t1 = < tipo_Identificador > {  e1 = new VarNode(t1); }
  (
   t1 = < LBRACKET > e2 = expression(null) < RBRACKET > //Porque null? P�gina impressa 105
   { e1 = new IndexNode(t1, e1, e2); }
  | 
    t1 = < DOT > t2 = < tipo_Identificador > [ < LPAREN > l = arglist(null) < RPAREN > ]
  )*
  { return e1; } 
} catch (ParseException e){
	consomeTokenAteh(g, e, "lvalue");
	return new VarNode(t1);
}
}

// funcao para instanciar de novos tipoos
void alocexpression(RecoverySet g) throws ParseEOFException :
{
    RecoverySet f1 = new RecoverySet(RPAREN).union(g),
  			  	f2 = new RecoverySet(RBRACKET).union(g);
}
{
  < NEW >
  (
    LOOKAHEAD(2)
    < tipo_Identificador > < LPAREN > arglist(f1) < RPAREN >
  |
    (
      < INT >
    | < STRING >
    | < tipo_Identificador >
    )
    (
      < LBRACKET > expression(f2) < RBRACKET >
    )+
  )
}
//ele falou algo sobre nao terminais que aceitam null devem ter o union.(g).final da p�gina impressa 115
// nivel mais alto de precedencia em expressoes
void expression(RecoverySet g) throws ParseEOFException :
{
}
{
    try {  
  	expr(g) ((< OR > | < XOR >) expression(g))*
  } catch (ParseException e) {
	consomeTokenAteh(g, e, "expression");
  }
  
}
void expr(RecoverySet g) throws ParseEOFException:
{}
{
	exp(g) (<AND> expr(g))*
}

void exp(RecoverySet g) throws ParseEOFException:
{}
{
	< NOT > comparexpression(g)
|
	comparexpression(g)
}

void comparexpression(RecoverySet g) throws ParseEOFException :
{}
{
	numexpr(g) [ ( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ> ) numexpr(g) ]
}

// nivel intermediario de precedencia
void numexpr(RecoverySet g) throws ParseEOFException :
{
}
{
  term(g)
  (
    (< PLUS > | < MINUS >) term(g)
  )*
}

// expressoes com prioridade de precedecia
void term(RecoverySet g) throws ParseEOFException :
{
}
{
  unaryexpr(g)
  (
    (< MULTIPLY > | < DIVIDE > | < REM >) unaryexpr(g)
  )*
}

// expressoes unarias que te mais alta precedencia perante a gramatica
void unaryexpr(RecoverySet g) throws ParseEOFException :
{
}
{
  [(< PLUS > | < MINUS >)] factor(g)
}

// fator que pode ser valorada ou chamada em recursivo com expressoes para encadeamento
void factor(RecoverySet g) throws ParseEOFException :
{
}
{
  (
    < tipo_INT >
  | 
    < tipo_STRING >
  | 
    < tipo_FLOAT >
  | 
    < tipo_NULL >
  | 
    < tipo_CHAR >
  | 
    < tipo_BOOLEAN >
  | 
    lvalue(g)
  | 
    < LPAREN > expression(g) < RPAREN >
  )
}

void arglist(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(COMMA).union(g);
}
{
  [
    expression(g)
    (
      < COMMA > expression(g)
    )*
  ]
}
