/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
}

PARSER_BEGIN(Fun)
package parser;
import java.io.*;

public class Fun
{
  final static String Version = "X++ Compiler - Version 1.0 - 2018";
  boolean Menosshort = false; //saida resumida == falso;

  //define o metodo "main" da classe langX.
  public static void main(String args []) throws ParseException
  {
    String filename = "C:/Users/Vitor/Downloads/UFSC/top.txt"; //nome do arquivo a ser analisado
    Fun parser; //analisador lexico/sintatico
    System.out.println(Version);
    //le do arquivo    
    System.out.println("Lendo do arquivo " + filename + "\n");
    try
    {
      parser = new Fun(new java.io.FileInputStream(filename));
    }
    catch (java.io.FileNotFoundException e)
    {
      System.out.println("Arquivo " + filename + " nao encontrado.");
      return;
    }
    parser.Menosshort = false;
    parser.program(); //chama o metodo que faz a analise
    //verifica se houve erro lexico
    if (parser.token_source.foundLexError() != 0)
    {
      System.out.println(parser.token_source.foundLexError() + " erros lexicos encontrados");
    }
    else
    {
      System.out.println("Programa analisado com sucesso!");
    }
  } //main

  static public String im(int x) //metodo auxiliar
  {
    int k;
    String s;
    s = tokenImage [x];
    k = s.lastIndexOf("\"");
    try
    {
      s = s.substring(1, k);
    }
    catch (StringIndexOutOfBoundsException e)
    {
    }
    return s;
  }
} // Fun

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
  int countLexError = 0;

  public int foundLexError()
  {
    return countLexError;
  }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

TOKEN : //operadores
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NEQ : "!=" >
| < REM : "%" >
| < NOT : "not" >
| < AND : "and" >
| < OR : "or" >
| < XOR : "xor" >
| < PWR : "^" >
}

TOKEN : //palavras reservadas
{
  < BREAK : "break" >
| < CLASS : "class" >
| < CONSTRUCTOR : "constructor" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FOR : "for" >
| < WHILE : "while" >
| < IF : "if" >
| < INT : "int" >
| < NEW : "new" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < STRING : "string" >
| < SUPER : "super" >
  //nosso
| < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
| < FUNCTION : "function" >
| < PUBLIC : "public" >
| < PROTECTED : "protected" >
| < PRIVATE : "private" >
| < FINAL : "final" >
}

TOKEN : //simbolos especiais
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

TOKEN :
{
  < tipo_INT :
    ( // numeros decimais, octais, hexadecimais ou binarios
      (
        [ "0"-"9" ] ([ "0"-"9" ])* //um ou mais digidos
      )
    ) >
    |
    < tipo_OCTAL :
    (
      (
        [ "0"-"7" ] ([ "0"-"7" ])* [ "o", "O" ] //um ou mais digitos de 0 a 7, seguidos de um o minusculo ou maiusculo
      )
    )>
    |
    < tipo_HEXADECIMAL :
    (     
      (
       // [ "0"-"9" ] ([ "0"-"7", "A"-"F", "a"-"f" ])* [ "h", "H" ]
        ([ "0"-"9", "A"-"F", "a"-"f" ])+ [ "h", "H" ] //um ou mais digitos de 0 a 9 ou de A a F em qualquer ordem, terminando com h maiusculo ou minusculo
      | ["0"]["x"]([ "0"-"9", "A"-"F", "a"-"f" ])*
      )
    )>
    | 
    <  tipo_BINARIO :
      (
        [ "0"-"1" ] ([ "0"-"1" ])* [ "b", "B" ] // digitos de 0 a 1 em qualquer ordem, terminando com b maiusculo ou minusculo
    ) >
| 
  < tipo_FLOAT :
    ( // floats
      (
        ([ "0"-"9" ])+ [ "." ] ([ "0"-"9" ])+ //pelo menos um digito de 0 a 9, seguido por um unico ponto e pelo menos mais um digito de 0 a 9
      )
    ) >
| 
  < tipo_STRING : // constante string como "ab cd"
    "\"" (~[ "\"", "\n", "\r" ])* "\"" > //aspas seguidas por qualquer coisa que nao seja aspas ou quebra de linha, terminando com aspas. Pode nao ter nada entre as aspas
| < tipo_NULL : "null" > //constante null
| < tipo_CHAR : // constante CHAR como 'a'
    "\'" (~[ "\'", "\n", "\r" ]) "\'" > //aspas simples seguidas por qualquer digito unico que nao seja aspas simples ou quebra de linha, terminando com as pas simples.
| < tipo_BOOLEAN :
    (
      "true"
    | "false"
    ) 
  >
}

TOKEN : //identificadores
{
  < tipo_Identificador : //qualquer combinacao de letras e numeros que comece com uma letra
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >
| 
  < #DIGIT : [ "0"-"9" ] >
}

SKIP : //comentarios
{
  "/*" : multilinecomment
}

/*
TOKEN: {
    < WHILE: "while" > : WHILEMODE
}
*/

< multilinecomment >
SKIP :
{
  "*/" : DEFAULT
| < ~[ ] >
}

SKIP :
{
  "//" : singlelinecomment
}

< singlelinecomment >
SKIP :
{
  < [ "\n", "\r" ] > : DEFAULT
| < ~[ ] >
}

SPECIAL_TOKEN : //trata erros lexicos
{
  < INVALID_LEXICAL : 
    (~[ "a"-"z", 
    "A"-"Z", 
    "0"-"9", 
    "\"", 
    "(", 
    ")", 
    "[", 
    "[", 
    "{", 
    "{", 
    ";", 
    ",", 
    ".", 
    "'", 
    "=", 
    ">", 
    "<", 
    "!", 
    "+", 
    "-", 
    "*", 
    "/", 
    "%", 
    " ", 
    "\t", 
    "\n", 
    "\r", 
    "\f" 
    ])+ >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Elemento invalido encontrado: " + image);
    countLexError++;
  }
| 
  < INVALID_CONST : 
    "\"" (~[ "\n", "\r", "\"" ])* [ "\n", "\r" ] >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - A constante possui uma quebra de linha inesperada: " + image);
    countLexError++;
  }
| 
  < INVALID_CHAR :
    "\'" (~[ "\n", "\r", "\'" ])* [ "\n", "\r" ]
  | 
    "\'" (~[ "\n", "\r", "\'" ]) (~[ "\n", "\r", "\'" ])+ "\'" 
  >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Erro de char. " + image);
    countLexError++;
  }
| 
  < INVALID_FLOAT :
    (
      ([ "0"-"9" ])+ ([ "." ])+ (([ "0"-"9" ])+ ([ "." ])+)+ //15.15.
    | ([ "0"-"9" ])+ ([ "." ])+ ([ "0"-"9" ])+ ([ "." ] ([ "0"-"9" ])+)+ //15.15.15
    | ([ "." ])+ ([ "0"-"9" ])+ ([ "." ])+ //.15.
    | ([ "." ])+ ([ "0"-"9" ])+ (([ "." ])+ ([ "0"-"9" ])+)+ //.15.15
    | ([ "." ])+ ([ "0"-"9" ])+(([ "." ])+ ([ "0"-"9" ])+ ([ "." ])+)+ //.15.15.
    | ([ "0"-"9" ])+ [ "." ] ([ "." ])+ ([ "0"-"9" ])+ //15..15    ) 
  >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - FLOAT INVALIDO: " + image);
    countLexError++;
  }
}

JAVACODE void program()
{
  Token t;
  do
  {
    t = getNextToken();
    Token st = t;
    boolean error = false;
    while (st.specialToken != null)
    {
      st = st.specialToken;
      error = true;
    }
    do
    {
      if (Menosshort) 
      System.out.println(st.image + "  " + im(st.kind) + " " + st.kind);
      else
      {
        if (im(st.kind) == "<INVALID_LEXICAL>" || im(st.kind) == "<INVALID_CONST>" || im(st.kind) == "<INVALID_CHAR>" || im(st.kind) == "<INVALID_FLOAT>")
        {
        }
        else
        {
          System.out.println("Linha: " + st.beginLine + " Coluna: " + st.beginColumn + " -> " + st.image + " " + im(st.kind));
        }
      }
      st = st.next;
    }
    while (st != t.next);
    if (error)
    {
      System.out.println("Linha: " + t.beginLine + " Coluna: " + t.beginColumn + " -> " + t.image + " " + im(t.kind));
    }
  }
  while (t.kind != FunConstants.EOF);
}
