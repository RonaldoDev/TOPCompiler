/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; //Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;
import java.io.*;

public class Fun
{
  final static String Version = "Top Compiler - Version 1.0 - 2018";
  int contadorDeErrosSintaticos = 0;	

  final static String CaminhoDoArquivo = "C:/Users/Ronaldo/Downloads/entradatestevalido.txt";

  public static void main(String args []) throws ParseException
  {
    boolean debug = false;
    String nomeArquivo = CaminhoDoArquivo;
    Fun analisador = leArquivo(nomeArquivo);
    System.out.println(Version);
    desabilitaVerboseDoAS(analisador, debug);
    try
    {
      analisador.program();
      //executaParser(analisador);
    }
    catch (ParseException e)
    {
      System.err.println(e.getMessage());
      analisador.contadorDeErrosSintaticos++;
    }
    finally
    {
      System.out.println(analisador.token_source.foundLexError() + ": Erros Lexicos encontrados");
      System.out.println(analisador.contadorDeErrosSintaticos + ": Erros Sintaticos encontratos");
    }
    if (temErros(analisador) == false)
    {
      System.out.println("Programa analisado com sucesso!");
    }
  } //main

  public static void desabilitaVerboseDoAS(Fun analisador, boolean debug)
  {
    if (!debug)
    {
      analisador.disable_tracing();
    }
  }

  public static boolean temErros(Fun analisador)
  {
    if (analisador.token_source.foundLexError() != 0)
    {
      System.out.println(analisador.token_source.foundLexError() + " erros lexicos encontrados");
    }
    return false;
  }

  public static Fun leArquivo(String nomeArquivo)
  {
    try
    {
      System.out.println("Lendo do arquivo " + nomeArquivo + "\n");
      return new Fun(new java.io.FileInputStream(nomeArquivo));
    }
    catch (java.io.FileNotFoundException e)
    {
      System.out.println("Arquivo " + nomeArquivo + " nao encontrado.");
      return null;
    }
  }

  public static void executaParser(Fun analisador)
  {
    analisador.Program();
  }

  static public String imagemToken(int x) //metodo auxiliar
  {
    int index;
    String strToken;
    strToken = tokenImage [x];
    index = strToken.lastIndexOf("\"");
    try
    {
      strToken = strToken.substring(1, index);
    }
    catch (StringIndexOutOfBoundsException e)
    {
    }
    return strToken;
  }

  public static Token geraTokenManipulacao(Token token)
  {
    token = getNextToken();
  }

  final public void classdecl() throws ParseException
  {
    trace_call("classdecl");
    try
    {
      jj_consume_token(CLASS);
      jj_consume_token(tipo_Identificador);
      switch ((jj_ntk == - 1) ? jj_ntk() : jj_ntk)
      {
        case EXTENDS : 
        jj_consume_token(EXTENDS);
        jj_consume_token(tipo_Identificador);
        break;
        default : 
        jj_la1 [1] = jj_gen;
        ;
      }
      classbody();
    }
    finally
    {
      trace_return("classdecl");
    }
  }
  
} // Fun

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
  int countLexError = 0;

  public int foundLexError()
  {
    return countLexError;
  }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

TOKEN : //operadores
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NEQ : "!=" >
| < REM : "%" >
| < NOT : "not" >
| < AND : "and" >
| < OR : "or" >
| < XOR : "xor" >
}

TOKEN : //palavras reservadas
{
  < BREAK : "break" >
| < CLASS : "class" >
| < CONSTRUCTOR : "constructor" >
| < ELSE : "else" >
| < EXTENDS : "extends" >
| < FOR : "for" >
| < WHILE : "while" >
| < IF : "if" >
| < INT : "int" >
| < NEW : "new" >
| < PRINT : "print" >
| < READ : "read" >
| < RETURN : "return" >
| < STRING : "string" >
| < SUPER : "super" >
  //nosso
| < FLOAT : "float" >
| < BOOLEAN : "boolean" >
| < CHAR : "char" >
}

TOKEN : //simbolos especiais
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

TOKEN :
{
  < tipo_INT :
    ( // numeros decimais, octais, hexadecimais ou binarios
      (
        [ "0"-"9" ] ([ "0"-"9" ])* //um ou mais digidos
      )
    ) >
| 
  < tipo_FLOAT :
    ( // floats
      (
        ([ "0"-"9" ])+ [ "." ] ([ "0"-"9" ])+ //pelo menos um digito de 0 a 9, seguido por um unico ponto e pelo menos mais um digito de 0 a 9
      )
    ) >
| 
  < tipo_STRING : // constante string como "ab cd"
    "\"" (~[ "\"", "\n", "\r" ])* "\"" > //aspas seguidas por qualquer coisa que nao seja aspas ou quebra de linha, terminando com aspas. Pode nao ter nada entre as aspas
| < tipo_NULL : "null" > //constante null
| < tipo_CHAR : // constante CHAR como 'a'
    "\'" (~[ "\\" ]) "\'"
  | "\'"
    (
      "\\n"
    | "\\r"
    | "\\t"
    | "\\\""
    | "\\\'"
    | "\\\\"
    )
    "\'" > //aspas simples seguidas por qualquer digito unico que nao seja aspas simples ou quebra de linha, terminando com as pas simples.
| < tipo_BOOLEAN :
    (
      "true"
    | "TRUE"
    | "false"
    | "FALSE"
    ) 
  >
}

TOKEN : //identificadores
{
  < tipo_Identificador : //qualquer combinacao de letras e numeros que comece com uma letra
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >
| 
  < #DIGIT : [ "0"-"9" ] >
}

SKIP : //comentarios
{
  "/*" : multilinecomment
}

< multilinecomment >
SKIP :
{
  "*/" : DEFAULT
| < ~[ ] >
}

SKIP :
{
  "//" : singlelinecomment
}

< singlelinecomment >
SKIP :
{
  < [ "\n", "\r" ] > : DEFAULT
| < ~[ ] >
}

SPECIAL_TOKEN : //trata erros lexicos
{
  < INVALID_LEXICAL : 
    (~[ "a"-"z", 
    "A"-"Z", 
    "0"-"9", 
    "\"", 
    "(", 
    ")", 
    "[", 
    "[", 
    "{", 
    "{", 
    ";", 
    ",", 
    ".", 
    "'", 
    "=", 
    ">", 
    "<", 
    "!", 
    "+", 
    "-", 
    "*", 
    "/", 
    "%", 
    " ", 
    "\t", 
    "\n", 
    "\r", 
    "\f" 
    ])+ >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Elemento invalido encontrado: " + image);
    countLexError++;
  }
| 
  < INVALID_STRING : 
    "\"" (~[ "\n", "\r", "\"" ])* [ "\n", "\r" ] >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - A string possui uma quebra de linha inesperada: " + image);
    countLexError++;
  }
| 
  < INVALID_CHAR :
    "\'" (~[ "\n", "\r", "\'" ])* [ "\n", "\r" ] //char com quebra de linha
  | 
    "\'" (~[ "\n", "\r", "\'" ]) (~[ "\n", "\r", "\'" ])+ "\'" //char com mais de um caractere
  | 
    "\'" "\'" //char vazio
  | 
    "\'" "\\" "\'" //char do tipo '\'
  >
  {
    System.err.println("Linha " + input_stream.getEndLine() + " - Char invalido: " + image);
    countLexError++;
  }
}



void program() :
{
}
{
  [ classlist() ] < EOF >
}

void classlist() :
{
}
{
  classdecl() [ classlist() ]
}

void classdecl() :
{
}
{
  < CLASS > < tipo_Identificador > [ < EXTENDS > < tipo_Identificador > ] classbody()
}

void vardecl() :
{
}
{
	( <INT> | <STRING> | <tipo_Identificador> | < CHAR > | < FLOAT > | < BOOLEAN >)
	<tipo_Identificador> ( <LBRACKET> <RBRACKET>)* (< ASSIGN > (< tipo_CHAR >|
	< tipo_STRING > | < tipo_INT > | < tipo_FLOAT > | < tipo_NULL >))?
	(<COMMA> <tipo_Identificador> ( <RBRACKET> <LBRACKET>)* )*
}

void contructdecl() :
{
}
{
	<CONSTRUCTOR> methodbody()
}

void methoddecl() :
{
}
{
  (< INT > | <STRING > | <tipo_Identificador >  | < CHAR > | < FLOAT > | < BOOLEAN >) (< RBRACKET >  <LBRACKET >)*
  < tipo_Identificador > methodbody()
    
}

void classbody() :
{
}
{
  < LBRACE >
  [classlist()]
  (LOOKAHEAD(3) vardecl() < SEMICOLON >)*
  (contructdecl())*
  (methoddecl())*
  < RBRACE >
}

void methodbody() :
{
}
{
  < LPAREN > paramlist() < RPAREN > statement()
    
}

void paramlist() : 
{
}
{
  [
  (< INT > | < STRING > | <tipo_Identificador > | < CHAR > | < FLOAT > | < BOOLEAN >) < tipo_Identificador > (< RBRACKET >  <LBRACKET >)*
  (< COMMA > (< INT > | < STRING > |  < tipo_Identificador > | < CHAR > | < FLOAT > | < BOOLEAN >) < tipo_Identificador > (< RBRACKET > <LBRACKET >)*
  )*
    ]
}

void statement() :
{
}
{
  LOOKAHEAD(2)
  vardecl()
| 
  atribstat() < SEMICOLON >
| 
  printstat() < SEMICOLON >
| 
  readstat() < SEMICOLON >
| 
  returnstat() < SEMICOLON >
| 
  superstat() < SEMICOLON >
| 
  ifstat()
| 
  forstat()
| 
  < LBRACE > statlist() < RBRACE >
| 
  < BREAK >< SEMICOLON >
| 
  < SEMICOLON >
  
}


void atribstat() :
{
}
{
  lvalue() < ASSIGN > (alocexpression() | expression())
|
  lvalue() < ASSIGN > (< tipo_CHAR > | < tipo_FLOAT > | < tipo_BOOLEAN >)
}


void printstat() :
{
}
{
  < PRINT > expression()
}


void readstat() :
{
}
{
  < READ > lvalue()
}


void returnstat() :
{
}
{
	< RETURN > [expression()]
}


void superstat() :
{
}
{
  < SUPER > <LPAREN > arglist() < RPAREN >
}


void ifstat():
{
}
{
  < IF > <LPAREN > expression() < RPAREN > statement()
  [LOOKAHEAD(1) < ELSE > statement()]
}


void forstat() :
{
}
{
  < FOR > <LPAREN > [atribstat()] <SEMICOLON >
  [expression()] <SEMICOLON >
  [atribstat()] <RPAREN >
  statement()
}


void statlist():
{
}
{
  statement() [statlist()]
}


void lvalue():
{
}
{
  < tipo_Identificador > (
    		< LBRACKET > expression() < RBRACKET > |
    		< DOT > <tipo_Identificador > [<LPAREN > arglist() < RPAREN >]
    		)*
}


void alocexpression():
{
}
{
  < NEW > (
    		LOOKAHEAD(2) < tipo_Identificador > <LPAREN > arglist() < RPAREN > |
    		(< INT > | < STRING > | < tipo_Identificador >)
    		(< LBRACKET > expression() < RBRACKET >)+
    	  )
}





void expression():
{
}
{
  numexpr() [( < LT > | < GT > | < LE > | < GE > | < EQ > | < NEQ >) numexpr()]
}


void numexpr():
{
}
{
  term() ((< PLUS > | < MINUS >) term())*
}


void term():
{
}
{
  unaryexpr() ((< MULTIPLY > | < DIVIDE > | < REM >) unaryexpr())*
}


void unaryexpr():
{
}
{
  [(< PLUS > | < MINUS >)] factor()
}


void factor():
{
}
{
  (
    < tipo_INT  > |
    < tipo_STRING  > |
    < tipo_NULL > |
    < tipo_Identificador >
    lvalue() |
    < LPAREN > expression() < RPAREN >)
}

void arglist():
{
}
{
  [expression() (< COMMA > expression())*]
}


//JAVACODE void program()
//{
//  Token token;
//  do
//  {
//    token = getNextToken();
//    Token tokenEspecial = token;
//    boolean isEstadoErro = false;
//    while (tokenEspecial.specialToken != null)
//    {
//      tokenEspecial = tokenEspecial.specialToken;
//      isEstadoErro = true;
//    }
//    do
//    {
//      if (imagemToken(tokenEspecial.kind) == "<INVALID_LEXICAL>" || imagemToken(tokenEspecial.kind) == "<INVALID_STRING>" || imagemToken(tokenEspecial.kind) == "<INVALID_CHAR>" || imagemToken(tokenEspecial.kind) == "<INVALID_FLOAT>")
//      { //Caso encontre algum dos erros acima, nao fazer nada, pois a mensagem de erro ja está implementada na propria verificacao de special tokens invalidos
//      }
//      else
//      {
//        System.out.println("Linha: " + tokenEspecial.beginLine + " Coluna: " + tokenEspecial.beginColumn + " -> " + tokenEspecial.image + " " + imagemToken(tokenEspecial.kind));
//      }
//      tokenEspecial = tokenEspecial.next; //st recebe o próximo token não especial
//    }
//    while (tokenEspecial != token.next); //verifica se o valor recebido no token st é igual ao próximo token a ser lido
//    if (isEstadoErro)
//    { //imprime o valor do token que sucede um erro léxico encontrado
//      System.out.println("Linha: " + token.beginLine + " Coluna: " + token.beginColumn + " -> " + token.image + " " + imagemToken(token.kind));
//    }
//  }
//  while (token.kind != FunConstants.EOF); //enquanto não chegar no final do arquivo
//  
//}

